\documentclass[11pt]{article}

\usepackage{MnSymbol}
\usepackage[T1]{fontenc}
\usepackage{algorithmic}
\usepackage{algorithm}
\usepackage[x11names,svgnames,dvipsnames]{xcolor}
\usepackage{listings}
\usepackage{geometry}
\usepackage[compact]{titlesec}
\usepackage[utf8]{inputenc}

\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}

\title{Cheatsheet Algorithms Lab 2013}
\author{Benjamin Gr√∂hbiel, ETH Zurich}

\geometry{a4paper, left=20mm, right=20mm, top=20mm, bottom=20mm}

\lstset{prebreak=\raisebox{0ex}[0ex][0ex]
        {\ensuremath{\rhookswarrow}}}
\lstset{postbreak=\raisebox{0ex}[0ex][0ex]
        {\ensuremath{\rcurvearrowse\space}}}
\lstset{breaklines=true, breakatwhitespace=true}
\lstset{numbers=left, numberstyle=\scriptsize}
\lstset{
basicstyle=\footnotesize\ttfamily,
basewidth  = {.5em,0.5em},
keywordstyle=\color{blue},
tabsize=4,
commentstyle=\color{dkgreen},
stringstyle=\color{mauve},
numberstyle=\tiny\color{gray},
language=C++,
breaklines=true,
breakautoindent=true,
frameround=ffff,
frame=single,
belowcaptionskip=3em,
belowskip=3em
}

\newcommand{\includecode}[1]{
    \lstinputlisting[   language=C++,
                        breaklines=true,
                        breakautoindent=true]{#1}}
                        
% making sure every section starts on new page.
\let\stdsection\section
\renewcommand\section{\newpage\stdsection}
\renewcommand{\thesection}{\hspace*{-1.0em}}    % removing numbering of section
\renewcommand{\thesubsection}{\hspace*{-1.0em}}    % numbering subsection
\renewcommand{\thesubsubsection}{\hspace*{-1.0em}}   

\begin{document}

\maketitle

\section{ACM Cheatsheet}
 
\subsection{Bit Operations}
\subsubsection{Checking if ith bit set:}
\begin{lstlisting}
int N = 3; // 0 1 1
for (int i = 0; i < 3; ++i) {
    int T = N & (1 << i);
	cout << i << " bit is " << T << "\n";
}
\end{lstlisting}

Outputs: 
\begin{lstlisting}
0 bit is 1
1 bit is 2
2 bit is 0
\end{lstlisting}

\subsubsection{Switch on ith Bit}
\begin{lstlisting}
// Bitwise OR: to turn on the jth element.
// 100010
// 001000 (0-indexed)
S = 34;
S |= (1 << 3);    // i = 3
cout << S << "\n";
\end{lstlisting}

\begin{lstlisting}
42
\end{lstlisting}

\subsubsection{Switch off ith Bit}
\begin{lstlisting}
// Turn off the jth element
// 101010
// 111101
S = 42;
T = S & ~(1 << 1);    // i = 1
cout << T << "\n";
\end{lstlisting}

\begin{lstlisting}
40
\end{lstlisting}

\subsubsection{Flipping ith Bit}
\begin{lstlisting}
// flip bit at jth position: 
S = 42;
S ^= (1 << 2);    // i = 2
cout << S << "\n";
\end{lstlisting}

\begin{lstlisting}
46
\end{lstlisting}

\subsubsection{Bit Multiplication}
\begin{lstlisting}
// Multiplication by 2: shifting the bits to the left
int S = 7;
S = S << 1;
cout << S << "\n";
\end{lstlisting}

\begin{lstlisting}
14
\end{lstlisting}

\subsubsection{Bit Division}
\begin{lstlisting}
// Dividing by 2: Shifting bits to the right
S = 7;
S = S >> 1;
cout << S << "\n";
\end{lstlisting}

\begin{lstlisting}
3
\end{lstlisting}

\subsubsection{Position of Least Significant Bit}
\begin{lstlisting}
S = 3;    // 0 1 1
T = (S & (-S));
cout << T << "\n";
\end{lstlisting}

\begin{lstlisting}
1    // 2^0
\end{lstlisting}

\subsection{Vector}
\subsubsection{Ascending sort}
\begin{lstlisting}
sort(points.begin(), points.end());
\end{lstlisting}

\subsubsection{Special sort (e.g. descending)}
\begin{lstlisting}
bool pairCompare(const pair<K::FT, K::Point_2>& lhs, const pair<K::FT, K::Point_2>& rhs) {
    return lhs.first > rhs.first;
}
sort(points.begin(), points.end(), pairCompare);
\end{lstlisting}

\subsection{Min Heap}
\begin{lstlisting}
priority_queue<int, vector<int>, greater<int> > min_heap;    // integers
priority_queue<pair<long long, int>, vector<pair<long long, int> >, greater<pair<long long, int> > > min_heap;    // pairs
\end{lstlisting}

\subsection{Powers of 2}
\begin{tabular}{ccc}
  Powers of 2 & Value & Powers of 10 \\
  $2^{0}$ & 1 & $10^{0}$ \\
  $2^{1}$ & 2 &  \\
  $2^{2}$ & 4 &  \\
  $2^{3}$ & 8 & $10^{1}$ \\
  $2^{4}$ & 16 & $10^{0}$ \\
  $2^{5}$ & 32 & $10^{0}$ \\
  $2^{6}$ & 64 & $10^{0}$ \\
  $2^{7}$ & 128 & $10^{3}$ \\
  $2^{8}$ & 256 & $10^{0}$ \\
  $2^{9}$ & 512 & $10^{0}$ \\
  $2^{10}$ & 1024 & $1000^{1}$ \\
  $2^{20}$ & 1048576 & $1000^{2}$ \\
  $2^{30}$ & 1073741824 & $1000^{3}$ \\
  $2^{40}$ &  & $1000^{4}$ \\
  $2^{50}$ &  & $1000^{5}$ \\
  $2^{60}$ &  & $1000^{6}$ \\
 \end{tabular}

%%%%%%%%%%%%

\section{BGL Cheatsheet}
\subsection{General Includes}
\begin{lstlisting}
#include <boost/graph/adjacency_list.hpp>
#include <boost/tuple/tuple.hpp>
#include <boost/graph/push_relabel_max_flow.hpp>
#include <boost/graph/max_cardinality_matching.hpp>
#include <boost/graph/boyer_myrvold_planar_test.hpp>
\end{lstlisting}

\subsection{Kruskal MST}
\begin{lstlisting}
#include <boost/graph/kruskal_min_spanning_tree.hpp>
vector<Edge> spanning_tree;
kruskal_minimum_spanning_tree(g, std::back_inserter(spanning_tree));
\end{lstlisting}

\subsection{Dijkstra Shortest Path}
\begin{itemize}
  \item Usage can output a warning.
\end{itemize}

\begin{lstlisting}
#include <boost/graph/dijkstra_shortest_paths.hpp>
// edge weight need to be set!
vector<int> d(N);
vector<Vertex> p(N);
dijkstra_shortest_paths(g, s, predecessor_map(&p[0]).distance_map(&d[0]));
\end{lstlisting}

\subsection{Undirected Graph}
\begin{itemize}
  \item 4. parameter: vertex properties, 5. parameter edge properties.
\end{itemize}
\begin{lstlisting}
typedef adjacency_list<vecS, vecS, undirectedS, no_property, no_property > Graph;
\end{lstlisting}

\subsection{Directed Graph}
\begin{lstlisting}
typedef adjacency_list<vecS, vecS, directedS, no_property, no_property> Graph;
\end{lstlisting}

\subsection{Strong Components}
\begin{lstlisting}
#include <boost/graph/strong_components.hpp>
vector<int> scc(N);
int nscc = strong_components(g, &scc[0]);
\end{lstlisting}

\subsection{Planarity testing}
\begin{itemize}
  \item Eulers formula: $F + V - E = 2$
\end{itemize}

\begin{lstlisting}
#include <boost/graph/boyer_myrvold_planar_test.hpp>
typedef adjacency_list<vecS, vecS, undirectedS, no_property, no_property> Graph;
bool isPlanar = boyer_myrvold_planarity_test(g);
\end{lstlisting}

\subsection{Maximum Matching Undirected Graph}
\begin{itemize}
  \item Maximum Matching = MVC
  \item |V| - |MVC| = MIS
  \item Given matching, obtain MVC by: 1) set all vertices to unvisited. 2) set all unmatched vertices in L to visited. 3) Run DFS from each visited vertex. 4) All unvisited vertices in L, and all visited vertices in R comprise the MVC.
\end{itemize}

\begin{lstlisting}
#include <boost/graph/max_cardinality_matching.hpp>
vector<Vertex> mateMap(num_vertices(g));
bool success = checked_edmonds_maximum_cardinality_matching(g, &mateMap[0]);
int matching = matching_size(g, &mateMap[0]); 

//Checking if vertex is unmatched:
mateMap[v_id] == graph_traits<Graph>::null_vertex()
\end{lstlisting}

\subsection{Network Flow}
\begin{itemize}
  \item Caution: no negative edge weight!
\end{itemize}

\begin{lstlisting}
#include <boost/tuple/tuple.hpp>
#include <boost/graph/adjacency_list.hpp>
#include <boost/graph/push_relabel_max_flow.hpp>

typedef adjacency_list_traits<vecS, vecS, directedS> Traits;
typedef adjacency_list<vecS, vecS, directedS, no_property,
  property<edge_capacity_t, long,
  property<edge_residual_capacity_t, long,
  property<edge_reverse_t, Traits::edge_descriptor> > > > Graph;
typedef property_map<Graph, edge_capacity_t>::type EdgeCapacityMap;
typedef property_map<Graph, edge_reverse_t>::type ReverseEdgeMap;
typedef graph_traits<Graph>::edge_descriptor Edge;

void add_edge(int from, int to, int cap, Graph& g) {
    EdgeCapacityMap capacity = get(edge_capacity, g);
    ReverseEdgeMap reverse = get(edge_reverse, g);
    
    Edge there, back;
    tie(there, tuples::ignore) = add_edge(from, to, g);
    tie(back, tuples::ignore) = add_edge(to, from, g);
    capacity[there] = cap;
    capacity[back] = 0;
    reverse[there] = back;
    reverse[back] = there;
}
\end{lstlisting}

\subsection{Max Flow}
\begin{lstlisting}
#include <boost/graph/push_relabel_max_flow.hpp>
int maxflow = push_relabel_max_flow(g, source, sink);
\end{lstlisting}

\subsection{Vertex And Edge Types}
\begin{lstlisting}
typedef graph_traits<Graph>::vertex_descriptor Vertex;
typedef graph_traits<Graph>::edge_descriptor Edge;
\end{lstlisting}

\subsection{Undirected Graph with Edge properties}
\begin{lstlisting}
typedef adjacency_list<vecS, vecS, undirectedS, no_property, property<edge_index_t, int, property<edge_weight_t, int> > > Graph;
\end{lstlisting}

\subsection{Property Maps}
\begin{lstlisting}
typedef property_map<Graph, vertex_index_t>::type IndexMap;
typedef property_map<Graph, edge_weight_t>::type WeightMap;
typedef property_map<Graph, edge_index_t>::type EdgeIndexMap;
\end{lstlisting}

\subsection{Instantiation Property Maps}
\begin{lstlisting}
EdgeIndexMap edgeIndex = get(edge_index, g);
WeightMap weightMap = get(edge_weight, g);
IndexMap indexMap = get(vertex_index, g);
\end{lstlisting}

\subsection{Iterators}
\begin{lstlisting}
typedef graph_traits<Graph>::edge_iterator EI;
typedef graph_traits<Graph>::out_edge_iterator OEI;
\end{lstlisting}

\subsection{Iterating over all edges}
\begin{lstlisting}
typedef graph_traits<Graph>::edge_iterator EI;
typedef graph_traits<Graph>::out_edge_iterator OEI;

EI ebegin, eend;
for(tie(ebegin, eend) = edges(g); ebegin != eend; ++ebegin) {
    // source(*ebegin, g);
    // target(*ebegin, g);
    // weightMap[*ebegin] = ...
}

OEI ebegin, eend;
for(tie(ebegin, eend) = out_edges(v, g); ebegin != eend; ++ebegin) {}
\end{lstlisting}

\subsection{Iterating over all vertices}
\begin{lstlisting}
typedef graph_traits<Graph>::vertex_iterator VI;
for(tie(vbegin, vend) = vertices(g); vbegin != vend; ++vbegin) {
    // vbegin is of type vertex_descriptor
    // *vbegin is an integer
}
\end{lstlisting}

\subsection{Iterating over adjacent vertices}
\begin{lstlisting}
typedef graph_traits<Graph>::adjacency_iterator AI;
AI ai, ai_end;
for(tie(ai,ai_end) = adjacent_vertices(v, g); ai != ai_end; ++ai){
    *ai   // vertex id
    ai    // vertex_descriptor
}
\end{lstlisting}

%%%%%%%%%%%%


\section{CGAL Cheatsheet}

\subsection{General}
\begin{lstlisting}
cin.sync_with_stdio(false);
cout << std::setiosflags(std::ios::fixed) << std::setprecision(0);
\end{lstlisting}

\begin{lstlisting}
CGAL::has_smaller_distance_to_point(origin, p1, p2)    // true p1 closer to origin, false p2 closer to origin 
CGAL::squared_distance(K::Point_2, K::Point_2);
\end{lstlisting}

\subsubsection{Includes}
\begin{itemize}
  \item Use exact construction for Min circle.
  \item If sqrt only needed for output, we can covert to double and use CGAL::sqrt.
\end{itemize}

\begin{lstlisting}
#include <CGAL/Exact_predicates_exact_constructions_kernel_with_sqrt.h>
#include <CGAL/Exact_predicates_exact_constructions_kernel.h>
#include <CGAL/Exact_predicates_inexact_constructions_kernel.h>

typedef CGAL::Exact_predicates_exact_constructions_kernel_with_sqrt K;
typedef CGAL::Exact_predicates_exact_constructions_kernel K;
typedef CGAL::Exact_predicates_inexact_constructions_kernel K;
\end{lstlisting}

\subsubsection{Ceil to double}
\begin{lstlisting}
double ceil_to_double(const K::FT& x) {
    double a = ceil(CGAL::to_double(x));
    while (a < x) a += 1;
    while (a-1 >= x) a -= 1;
    return a;
}
\end{lstlisting}

\subsubsection{Floor to double}
\begin{lstlisting}
double floor_to_double(const K::FT& x) {
  double a = std::floor(CGAL::to_double(x));
  while (a > x) a -= 1;
  while (a+1 <= x) a += 1;
  return a;
}
\end{lstlisting}

\subsection{Min Circle}
\begin{lstlisting}
#include <CGAL/Min_circle_2.h>
#include <CGAL/Min_circle_2_traits_2.h>
\end{lstlisting}

\begin{lstlisting}
typedef CGAL::Min_circle_2_traits_2<K> Traits;
typedef CGAL::Min_circle_2<Traits> Min_circle;
\end{lstlisting}

\begin{lstlisting}
Min_circle mc(points.begin(), points.end(), true);
for(Min_circle::Support_point_iterator it = mc.support_points_begin(); it != mc.support_points_end(); ++it) {}
\end{lstlisting}

\begin{lstlisting}
Traits::Circle c = mc.circle();
c.squared_radius();
\end{lstlisting}

\subsection{Intersections}
\begin{lstlisting}
if(CGAL::do_intersect(ray, obstacle)) {    // could be any two geometric shapes.
    K::Point_2 intersection_point;
	CGAL::Object o = CGAL::intersection(ray, obstacle);
}	
if(const K::Point_2* p = CGAL::object_cast<K::Point_2>(&o)) {
    intersection_point = *p;    // important: reference
}
else if (const K::Segment_2* s = CGAL::object_cast<K::Segment_2>(&o))
    intersection_point = s->source();    //important: now object ->.
}
else throw runtime_error("strange segment intersection");
\end{lstlisting}

\subsection{Delauny Triangulation}
\begin{lstlisting}
#include <CGAL/Delaunay_triangulation_2.h>
typedef CGAL::Delaunay_triangulation_2<K> Delaunay;
// Find nearest Delaunay vertex:
Triangulation::Vertex_handle v = t.nearest_vertex(Point);
\end{lstlisting}

\begin{lstlisting}
vector<K::Point_2> points;
Delaunay t;
t.insert(points.begin(), points.end());
t.nearest_vertex(K::Point_2);    // returns Vertex_handle to nearest point.
\end{lstlisting}

\begin{lstlisting}
Delaunay::Face_handle start_face = t.locate(coord);
if(t.is_infinite(start_face)) {}
\end{lstlisting}
      
\subsubsection{Iterate over finite edges}
\begin{lstlisting}
typedef Delaunay::Finite_edges_iterator FEI;
\end{lstlisting}

\begin{lstlisting}
for(FEI edge = t.finite_edges_begin(); edge != t.finite_edges_end(); ++edge) {
    Delaunay::Vertex_handle v1 = edge->first->vertex((edge->second + 1) % 3);
    Delaunay::Vertex_handle v2 = edge->first->vertex((edge->second + 2) % 3);
    K::Segment_2 seg = t.segment(edge);
}
\end{lstlisting}

    
\subsubsection{Iterate over finite vertices}
\begin{lstlisting}
typedef Delaunay::Finite_vertices_iterator FVI;

for(FVI p = t.finite_vertices_begin(); p != t.finite_vertices_end(); ++p) {
    Delaunay::Vertex_handle vertex = p;
    vertex->point();    // returns K::Point_2
}
\end{lstlisting}

\subsection{Vertex, Edge, Face information}

\subsubsection{Edge information in map}
\begin{lstlisting}
map<Delaunay::Vertex_handle, int> vertices;
map<Delaunay::Face_handle, int> faces;
map<Edge, int> edges;
\end{lstlisting}

\subsubsection{Vertex base with info}
\begin{lstlisting}
#include <CGAL/Triangulation_vertex_base_with_info_2.h>
typedef CGAL::Triangulation_vertex_base_with_info_2<int, K> Vb;
typedef CGAL::Triangulation_data_structure_2<Vb> Tds;
typedef CGAL::Delaunay_triangulation_2<K, Tds> Delaunay;
\end{lstlisting}

\begin{lstlisting}
// set info while inserting
vector<pair<K::Point_2, int> > points;    // the second param is used as vertex id.
vector<K::Point_2> points;
Delaunay t;
t.insert(points.begin(), points.end());

// access info
Delaunay::Vertex_handle vertex = p;
p->info() = 1;
\end{lstlisting}

\subsubsection{Face base with info}
\begin{lstlisting}
#include <CGAL/Triangulation_face_base_with_info_2.h>
Triangulation_face_base_with_info_2<int,Traits,Fb>
...
\end{lstlisting}

\subsection{Linear Programming}
\begin{lstlisting}
#include <cassert>
#include <CGAL/basic.h>
#include <CGAL/QP_models.h>
#include <CGAL/QP_functions.h>
\end{lstlisting}


\begin{lstlisting}
#ifdef CGAL_USE_GMP
#include <CGAL/Gmpz.h>    // Use Gmpz for integers, Gmpq for double.
typedef CGAL::Gmpz ET;
#else
#include <CGAL/MP_Float.h>
typedef CGAL::MP_Float ET;
#endif
\end{lstlisting}

\begin{lstlisting}
typedef CGAL::Quadratic_program<int> Program;
typedef CGAL::Quadratic_program_solution<ET> Solution;
\end{lstlisting}

\begin{lstlisting}
Program qp(CGAL::SMALLER, true, 0, false, 0);

qp.set_a(COL j, ROW i, VAL);    // COL = variable, ROW = constraint
qp.set_b(ROW i, VAL);
qp.set_r(ROW i, CGAL::SMALLER/CGAL::LARGER);
qp.set_d(VAR1, VAR2, 2*VAL);    // for quadratic programs only
qp.set_c(VAR, VAL);
qp.set_c0(VAL);

Solution s = CGAL::solve_quadratic_program(qp, ET());
Solution s = CGAL::solve_linear_program(lp, ET());

s.is_optimal()
s.is_infeasible()
s.is_unbounded()
CGAL::to_double(s.objective_value())
\end{lstlisting}

%%%%%%%%%%%%

\section{Snippets}

\subsection{Merge sort}
\includecode{../snippets/MergeSort.cpp}

\subsection{DP LIS}
\includecode{../snippets/LIS_Iterative.cpp}
\includecode{../snippets/LIS_recursive.cpp}

The following snippets solves the LIS problem in $O(n log n)$. It is based on patience sorting (piles of decreasing cards).
\includecode{../snippets/LIS_greedy.cpp}

\subsection{Union Find}
Union find data structure keeps track of sets and has complexities $O(1)$ for checking if an object is in the same set, and inserting a new object relation. 
\includecode{../snippets/UnionFind.cpp}

\subsection{Print Euler Tour}
Based on vertices, see Bracelet problem for edge-based solution.
\includecode{../snippets/EulerianCycle.cpp}

\subsection{Shortest Path in DAG}
\includecode{../snippets/DAG_SSSP.cpp}

\subsection{Stack based DFS}
\includecode{../snippets/DFS_iterative.cpp}

\subsection{Recursive DFS}
\includecode{../snippets/DFS_recursive.cpp}

\end{document}